import logging
import os

from asyncio import Lock
from logging.handlers import TimedRotatingFileHandler


## Logging

# Create log directory if it doesn't already exist
os.makedirs("log", exist_ok=True)

LOGFORMAT = "%(asctime)s  %(levelname)-10s %(message)s"
formatter = logging.Formatter(LOGFORMAT, datefmt="%Y-%m-%d %H:%M:%S")

handler = TimedRotatingFileHandler("log/log.log", when="midnight",
                                   encoding="utf-8")
handler.setFormatter(formatter)
handler.setLevel(logging.DEBUG)

console_handler = logging.StreamHandler()
console_handler.setFormatter(formatter)
console_handler.setLevel(logging.INFO)

logger = logging.getLogger("Kamlbot")
logger.setLevel(logging.INFO)
logger.addHandler(handler)
logger.addHandler(console_handler)


## asyncio locks
locks = {}  # Dictionary of all locks generated by `get_lock`.


def get_lock(lock_name):
    """Get the lock with the given name, create it if it doesn't already exists."""
    if lock_name not in locks:
        locks[lock_name] = Lock()

    return locks[lock_name]


def locking(lock_name):
    """Decorator factory that apply a lock for the duration of the function.

    This means that another function with the same lock can not run at the same
    time. It is used to avoid that an async function modify the data used by another
    async function (which may screw everything).
    """
    lock = get_lock(lock_name)

    def _decorator(func):
        async def _locked_fn(*args, **kwargs):
            async with lock:
                res = await func(*args, **kwargs)
            return res

        return _locked_fn

    return _decorator


## Signal
signal_callbacks = {}  # Dictionary of all signal callbacks.


def connect(signal_name, func):
    """Connect the function `func` to a signal.

    That means that when a signal of this name is emitted (using `emit_signal`),
    the function `func` will be executed.
    """
    if signal_name not in signal_callbacks:
        signal_callbacks[signal_name] = []

    if func not in signal_callbacks[signal_name]:
        signal_callbacks[signal_name].append(func)


async def emit_signal(signal_name, *args, **kwargs):
    """Emit a signal with, executing all functions connected to it.

    Additional arguments are passed down to the connected functions.
    """
    if signal_name in signal_callbacks:
        for func in signal_callbacks[signal_name]:
            await func(*args, **kwargs)


## Misc

class ChainedDict:
    """Class chaining two dicts."""
    def __init__(self, key_to_mid, mid_to_value):
        self.key_to_mid = key_to_mid
        self.mid_to_value = mid_to_value

    def __getitem__(self, key):
        return self.mid_to_value[self.key_to_mid[key]]


class RankedObject:
    next_object = None
    previous_object = None
    rank = 1

    def __init__(self, item, key):
        self.item = item
        self.key = key

    def __str__(self):
        return f"[{self.rank}] {self.key} : {self.item}"


class RankedDict:
    first = None
    last = None

    def __init__(self, dictionary=None):
        self.dict = {}
        if dictionary is not None:
            for key, item in dictionary.items():
                self.append(item, key)
                self.dict[key] = self.last

    def __iter__(self):
        obj = self.first
        k = 1

        while obj is not None and k <= len(self):
            print(obj)
            k += 1
            yield obj.item
            obj = obj.next_object

        if k > len(self):
            raise Exception("RankedDict iteration looping too much.")

    def __getitem__(self, pos):
        return self.get_obj(pos).item

    def __len__(self):
        if self.first is None:
            return 0
        return self.last.rank

    def __str__(self):
        s = ""

        for r, item in enumerate(self):
            s += f"{r+1} : {item}\n"

        return s

    def append(self, item, key=None):
        obj = RankedObject(item, key)
        self.dict[key] = obj

        if len(self) == 0:
            self.first = obj
            self.last = obj

        else:
            obj.rank = len(self) + 1

            obj.previous_object = self.last
            self.last.next_object = obj

            self.last = obj

    def delete(self, key=None, pos=None):
        if pos is not None:
            obj = self.get_obj(pos)
            key = obj.key

        if key is not None:
            if key not in self.dict:
                return

            obj = self.dict[key]

            if obj.previous_object is not None:
                obj.previous_object.next_object = obj.next_object

            if obj.next_object is not None:
                obj.next_object.previous_object = obj.previous_object

        else:
            raise Exception("Either key or pos should be set.")

    def get(self, key, default=None):
        if key not in self.dict:
            return default

        return self.dict[key].item

    def get_obj(self, pos):
        pos -= 1  # Use base 1 indexing
        obj = self.first

        for _ in range(pos):
            obj = obj.next_object

        return obj

    def get_rank(self, key):
        return self.dict[key].rank

    def insert(self, pos, item, key=None):
        after = self.get_obj(pos)

        if after is None:
            self.append(item, key)

        else:
            obj = RankedObject(item, key)
            self.dict[key] = obj

            before = after.previous_object
            before.next_object = obj
            obj.previous_object = before

            after.previous_object = obj
            obj.next_object = after

            while after is not None:
                after.rank += 1
                after = after.next_object

    def items(self):
        return self.dict.items()


def partition(N, parts=2):
    """Return all partition of integer `N` in a fixed number of parts."""

    if parts == 1:
        yield (N,)
    else:
        for i in range(1, N):
            for p in partition(N - i, parts - 1):
                yield (i,) + p
